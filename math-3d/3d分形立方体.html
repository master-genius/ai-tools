<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cyber Menger - Fixed & Robust</title>
  <style>
    body { margin: 0; overflow: hidden; background-color: #050505; }
    canvas { display: block; width: 100vw; height: 100vh; }
    
    #ui {
      position: absolute;
      bottom: 30px;
      width: 100%;
      text-align: center;
      color: #00eaff;
      font-family: monospace;
      font-size: 14px;
      letter-spacing: 2px;
      pointer-events: none;
      text-shadow: 0 0 8px rgba(0, 234, 255, 0.6);
    }
    #loading {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      color: #fff;
      font-family: sans-serif;
      font-weight: bold;
      letter-spacing: 2px;
      pointer-events: none;
      transition: opacity 0.3s;
    }
  </style>
</head>
<body>
  <div id="loading">INITIALIZING SYSTEMS...</div>
  <canvas id="glcanvas"></canvas>
  <div id="ui">SYSTEM ONLINE // GPU INSTANCING ACTIVE</div>

  <!-- 顶点着色器 -->
  <script id="vs" type="x-shader/x-vertex">
    attribute vec3 position;
    attribute vec3 normal;
    
    // 实例属性 (Instanced Attributes)
    attribute vec3 offset;   // 位置
    attribute float scale;   // 大小
    attribute vec3 color;    // 颜色

    uniform mat4 u_matrix;   // 投影 * 视图 矩阵
    uniform float u_time;

    varying vec3 v_normal;
    varying vec3 v_color;
    varying vec3 v_pos;

    // 简单的旋转逻辑
    vec3 rotateY(vec3 p, float angle) {
        float c = cos(angle);
        float s = sin(angle);
        return vec3(p.x * c - p.z * s, p.y, p.x * s + p.z * c);
    }

    void main() {
      // 动画：呼吸效果
      float dist = length(offset);
      float breathe = sin(u_time * 2.0) * 0.5 + 0.5; // 0-1
      float expand = 1.0 + breathe * 0.3 * smoothstep(0.0, 1.5, dist);

      // 局部旋转：只有小方块旋转
      vec3 pos = position * scale; // 先缩放
      if (scale < 0.25) {
          pos = rotateY(pos, u_time * 1.5 + dist);
      }

      // 应用位移
      vec3 worldPos = pos + offset * expand;

      v_pos = worldPos;
      v_normal = normal; 
      
      // 动态颜色增强
      v_color = color;
      if (scale < 0.2) {
         v_color += vec3(0.4, 0.3, 0.0) * breathe; // 核心闪烁
      }

      gl_Position = u_matrix * vec4(worldPos, 1.0);
    }
  </script>

  <!-- 片元着色器 -->
  <script id="fs" type="x-shader/x-fragment">
    precision mediump float;

    varying vec3 v_normal;
    varying vec3 v_color;
    varying vec3 v_pos;

    void main() {
      vec3 normal = normalize(v_normal);
      
      // 光照配置
      vec3 lightPos = vec3(2.0, 2.0, 5.0);
      vec3 lightDir = normalize(lightPos - v_pos);
      
      // 1. 基础环境光
      vec3 ambient = vec3(0.02, 0.02, 0.05);

      // 2. 漫反射
      float diff = max(dot(normal, lightDir), 0.0);

      // 3. 边缘光 (Rim Light) - 增加立体感
      vec3 viewDir = normalize(vec3(0.0, 0.0, 5.0) - v_pos);
      float rim = 1.0 - max(dot(viewDir, normal), 0.0);
      rim = smoothstep(0.6, 1.0, rim);
      vec3 rimColor = vec3(0.0, 0.5, 1.0) * rim;

      // 组合光照
      vec3 lighting = ambient + (diff * vec3(1.0, 0.9, 0.8));
      
      vec3 finalColor = v_color * lighting + rimColor;

      // 伽马校正 (使得暗部不那么死黑)
      gl_FragColor = vec4(pow(finalColor, vec3(1.0/2.2)), 1.0);
    }
  </script>

  <script>
    const canvas = document.getElementById('glcanvas');
    const gl = canvas.getContext('webgl', { alpha: false });
    const loading = document.getElementById('loading');

    if (!gl) {
        alert("WebGL not supported");
        throw new Error("WebGL not supported");
    }

    // 检查 Instancing 扩展支持
    const ext = gl.getExtension('ANGLE_instanced_arrays');
    if (!ext) {
        alert("Need ANGLE_instanced_arrays");
        throw new Error("Need ANGLE_instanced_arrays");
    }

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      gl.viewport(0, 0, canvas.width, canvas.height);
    }
    window.addEventListener('resize', resize);
    resize();

    // --- 1. Menger Sponge 生成逻辑 ---
    const instances = [];
    const COLOR_OUTER = [0.1, 0.12, 0.15]; // 装甲黑
    const COLOR_MID   = [0.0, 0.5, 0.8];   // 科技蓝
    const COLOR_CORE  = [1.0, 0.6, 0.1];   // 熔岩金

    function generateMenger(x, y, z, size, depth) {
        if (depth === 0) {
            let col = COLOR_OUTER;
            if (size < 0.6) col = COLOR_MID;
            if (size < 0.2) col = COLOR_CORE;
            
            instances.push(x, y, z, size, col[0], col[1], col[2]);
            return;
        }
        
        let subSize = size / 3.0;
        for (let dx = -1; dx <= 1; dx++) {
            for (let dy = -1; dy <= 1; dy++) {
                for (let dz = -1; dz <= 1; dz++) {
                    let zeros = 0;
                    if (dx === 0) zeros++;
                    if (dy === 0) zeros++;
                    if (dz === 0) zeros++;
                    
                    // 如果不是中间被挖空的部分，继续递归
                    if (zeros < 2) {
                        generateMenger(x + dx * subSize, y + dy * subSize, z + dz * subSize, subSize, depth - 1);
                    }
                }
            }
        }
    }

    // 生成3级海绵 (约2000+个方块)
    generateMenger(0, 0, 0, 2.4, 3);
    
    const instanceData = new Float32Array(instances);
    const instanceCount = instances.length / 7;
    console.log("Cube Count:", instanceCount);
    
    loading.style.opacity = 0;

    // --- 2. 基础 Cube 模型 ---
    // 简单的立方体顶点和法线
    // 格式: X, Y, Z, NX, NY, NZ
    const cubeData = new Float32Array([
        // Front
        -0.5,-0.5, 0.5,  0,0,1,   0.5,-0.5, 0.5,  0,0,1,   0.5, 0.5, 0.5,  0,0,1,
        -0.5,-0.5, 0.5,  0,0,1,   0.5, 0.5, 0.5,  0,0,1,  -0.5, 0.5, 0.5,  0,0,1,
        // Back
        -0.5,-0.5,-0.5,  0,0,-1, -0.5, 0.5,-0.5,  0,0,-1,  0.5, 0.5,-0.5,  0,0,-1,
        -0.5,-0.5,-0.5,  0,0,-1,  0.5, 0.5,-0.5,  0,0,-1,  0.5,-0.5,-0.5,  0,0,-1,
        // Top
        -0.5, 0.5,-0.5,  0,1,0,  -0.5, 0.5, 0.5,  0,1,0,   0.5, 0.5, 0.5,  0,1,0,
        -0.5, 0.5,-0.5,  0,1,0,   0.5, 0.5, 0.5,  0,1,0,   0.5, 0.5,-0.5,  0,1,0,
        // Bottom
        -0.5,-0.5,-0.5,  0,-1,0,  0.5,-0.5,-0.5,  0,-1,0,  0.5,-0.5, 0.5,  0,-1,0,
        -0.5,-0.5,-0.5,  0,-1,0,  0.5,-0.5, 0.5,  0,-1,0, -0.5,-0.5, 0.5,  0,-1,0,
        // Right
         0.5,-0.5,-0.5,  1,0,0,   0.5, 0.5,-0.5,  1,0,0,   0.5, 0.5, 0.5,  1,0,0,
         0.5,-0.5,-0.5,  1,0,0,   0.5, 0.5, 0.5,  1,0,0,   0.5,-0.5, 0.5,  1,0,0,
        // Left
        -0.5,-0.5,-0.5, -1,0,0,  -0.5,-0.5, 0.5, -1,0,0,  -0.5, 0.5, 0.5, -1,0,0,
        -0.5,-0.5,-0.5, -1,0,0,  -0.5, 0.5, 0.5, -1,0,0,  -0.5, 0.5,-0.5, -1,0,0,
    ]);

    // --- 3. Shader 编译 ---
    function createShader(gl, type, src) {
        const s = gl.createShader(type);
        gl.shaderSource(s, src);
        gl.compileShader(s);
        if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
            console.error(gl.getShaderInfoLog(s)); return null;
        }
        return s;
    }
    const program = gl.createProgram();
    gl.attachShader(program, createShader(gl, gl.VERTEX_SHADER, document.getElementById('vs').textContent));
    gl.attachShader(program, createShader(gl, gl.FRAGMENT_SHADER, document.getElementById('fs').textContent));
    gl.linkProgram(program);
    gl.useProgram(program);

    // --- 4. 数据绑定 ---
    // 几何 Buffer
    const vbo = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
    gl.bufferData(gl.ARRAY_BUFFER, cubeData, gl.STATIC_DRAW);

    const posLoc = gl.getAttribLocation(program, 'position');
    gl.enableVertexAttribArray(posLoc);
    gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 24, 0);

    const normLoc = gl.getAttribLocation(program, 'normal');
    gl.enableVertexAttribArray(normLoc);
    gl.vertexAttribPointer(normLoc, 3, gl.FLOAT, false, 24, 12);

    // 实例 Buffer
    const iBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, iBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, instanceData, gl.STATIC_DRAW);

    const offsetLoc = gl.getAttribLocation(program, 'offset');
    gl.enableVertexAttribArray(offsetLoc);
    gl.vertexAttribPointer(offsetLoc, 3, gl.FLOAT, false, 28, 0);
    ext.vertexAttribDivisorANGLE(offsetLoc, 1); // 关键：每个实例更新一次

    const scaleLoc = gl.getAttribLocation(program, 'scale');
    gl.enableVertexAttribArray(scaleLoc);
    gl.vertexAttribPointer(scaleLoc, 1, gl.FLOAT, false, 28, 12);
    ext.vertexAttribDivisorANGLE(scaleLoc, 1);

    const colorLoc = gl.getAttribLocation(program, 'color');
    gl.enableVertexAttribArray(colorLoc);
    gl.vertexAttribPointer(colorLoc, 3, gl.FLOAT, false, 28, 16);
    ext.vertexAttribDivisorANGLE(colorLoc, 1);

    const uMatrix = gl.getUniformLocation(program, 'u_matrix');
    const uTime = gl.getUniformLocation(program, 'u_time');

    // --- 5. 稳健的矩阵库 (Column-Major) ---
    const Mat4 = {
        perspective: function(out, fov, aspect, near, far) {
            const f = 1.0 / Math.tan(fov / 2);
            const nf = 1 / (near - far);
            out[0] = f / aspect; out[1] = 0; out[2] = 0; out[3] = 0;
            out[4] = 0; out[5] = f; out[6] = 0; out[7] = 0;
            out[8] = 0; out[9] = 0; out[10] = (far + near) * nf; out[11] = -1;
            out[12] = 0; out[13] = 0; out[14] = (2 * far * near) * nf; out[15] = 0;
        },
        lookAt: function(out, eye, center, up) {
            let x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
            let eyex = eye[0], eyey = eye[1], eyez = eye[2];
            let upx = up[0], upy = up[1], upz = up[2];
            let centerx = center[0], centery = center[1], centerz = center[2];

            z0 = eyex - centerx; z1 = eyey - centery; z2 = eyez - centerz;
            len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
            z0 *= len; z1 *= len; z2 *= len;

            x0 = upy * z2 - upz * z1; x1 = upz * z0 - upx * z2; x2 = upx * z1 - upy * z0;
            len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
            if (!len) { x0 = 0; x1 = 0; x2 = 0; } else { len = 1 / len; x0 *= len; x1 *= len; x2 *= len; }

            y0 = z1 * x2 - z2 * x1; y1 = z2 * x0 - z0 * x2; y2 = z0 * x1 - z1 * x0;
            len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
            if (!len) { y0 = 0; y1 = 0; y2 = 0; } else { len = 1 / len; y0 *= len; y1 *= len; y2 *= len; }

            out[0] = x0; out[1] = y0; out[2] = z0; out[3] = 0;
            out[4] = x1; out[5] = y1; out[6] = z1; out[7] = 0;
            out[8] = x2; out[9] = y2; out[10] = z2; out[11] = 0;
            out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
            out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
            out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
            out[15] = 1;
        },
        multiply: function(out, a, b) {
            let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
            let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
            let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
            let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

            let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
            out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
            out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
            out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
            out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

            b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
            out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
            out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
            out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
            out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

            b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
            out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
            out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
            out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
            out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

            b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
            out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
            out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
            out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
            out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
        }
    };

    // --- 6. 渲染循环 ---
    gl.enable(gl.DEPTH_TEST);
    gl.enable(gl.CULL_FACE);

    const projMat = new Float32Array(16);
    const viewMat = new Float32Array(16);
    const viewProjMat = new Float32Array(16);

    let mouseX = 0, mouseY = 0;
    document.addEventListener('mousemove', e => {
        mouseX = (e.clientX / window.innerWidth - 0.5) * 2.0;
        mouseY = (e.clientY / window.innerHeight - 0.5) * 2.0;
    });

    function render(time) {
        time *= 0.001;

        gl.clearColor(0.05, 0.05, 0.05, 1.0); // 深灰背景，确保能看到clear
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        const aspect = canvas.width / canvas.height;
        Mat4.perspective(projMat, Math.PI / 4, aspect, 0.1, 100.0);
        
        // 摄像机位置：缓慢旋转
        const r = 4.5;
        const camX = Math.sin(time * 0.2 + mouseX) * r;
        const camY = Math.sin(time * 0.1 + mouseY) * 2.0;
        const camZ = Math.cos(time * 0.2 + mouseX) * r;

        Mat4.lookAt(viewMat, [camX, camY, camZ], [0, 0, 0], [0, 1, 0]);
        Mat4.multiply(viewProjMat, projMat, viewMat); // 注意乘法顺序 P * V

        gl.uniformMatrix4fv(uMatrix, false, viewProjMat);
        gl.uniform1f(uTime, time);

        // 绘制
        ext.drawArraysInstancedANGLE(gl.TRIANGLES, 0, 36, instanceCount);

        requestAnimationFrame(render);
    }
    requestAnimationFrame(render);

  </script>
</body>
</html>